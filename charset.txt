‚á® // start, going right
‚á¶ // start, going left
‚áß // start, going up
‚á© // start, going down
‚≠¨ // move current baseline up 1
‚≠™ // move current baseline down 1
‚≠´ // go to next baseline, if none, create new baseline at the end of <main>
üîî // bell character
‚êà // delete the last console char
‚≠≠ // go to last baseline, if none, go to index 0
\n // newline
‚≠Æ // rotate counterclockwise
‚≠Ø // rotate clockwise
‚Æï // move right arrow
‚¨Ö // move left arrow
‚¨Ü // move up arrow
‚¨á // move down arrow
‚¨å // horizontal dual arrow
‚¨ç // vertical dual arrow
‚èú // loop left top
‚èù // loop left bottom
‚é¥ // goto middle top
‚éµ // goto middle bottom
‚èû // loop right top
‚èü // loop right bottom
‚ãÆ // vertical conditional mirror
‚ãØ // horizontal conditional mirror
‚êõ // exit the program (escape)
‚ã∞ // identity-line conditional mirror
‚ã± // inverse-line conditional mirror
‚¨Ñ // start random horizontal
‚á≥ // start random vertical
  // no-op
! // output top of <mid>
" // literal '
# // random
$ // get environment variable with name of <mid>
% // modulo
& // join from <baseline>
' // start and end a string
( // loop if <left> is true or empty
) // loop if <left> is true or empty
* // dot product
+ // plus
, // from <left>, in steps of <right>
- // minus
. // from zero to <mid>, in steps of 1
/ // reflection around SW->NE
0 // multiply <mid> by 10
1 // multiply <mid> by 10, add 1
2 // multiply <mid> by 10, add 2
3 // multiply <mid> by 10, add 3
4 // multiply <mid> by 10, add 4
5 // multiply <mid> by 10, add 5
6 // multiply <mid> by 10, add 6
7 // multiply <mid> by 10, add 7
8 // multiply <mid> by 10, add 8
9 // multiply <mid> by 10, add 9
: // from <mid> away from zero in steps of 1
; // from <left>, in magnitudes of <right>
< // less-than
= // top-equals
> // greater-than
? // get single char of input, store in <mid>
@ // move the <mid>th stack from the cursor to the top
A // uppercase alphabet
B // convert <left> to a bunch of digits, in the base of <right>
C // arc-cosine
D // remove duplicates from <mid>
E // e^x
F // permutations of <mid>
G // greatest-common-divisor
H // maximum of <mid>
I // just the imaginary part
J // just the real part
K // keep from <left> where not <right>
L // log <left> in base of <right>
M // combinations of <mid>
N // join <main> with newlines
O // is ordered
P // is prime
Q // do a quine
R // is a finite real number
S // arc-sine
T // arc-tangent
U // upend the mid stack
V // average
W // wipe the mid stack
X // to uppercase
Y // is uppercase
Z // is a finite number
[ // goto if <mid> is true
\ // reflection around NW->SE
] // goto if <mid> is true
^ // exponentiate
_ // floor
` // restart the program. If the start was random, choose another start accordingly.
a // lowercase alphabet
b // convert <left> stack to an integer, assuming it's in the base of <right>
c // cosine
d // retain only duplicates from <mid>
e // natural logarithm
f // integer permutation using top of <left> and <right>
g // least-common-multiple
h // minimum of <mid>
i // multiply <mid> by imaginary unit
j // split an imaginary number into re <left>, im <right>
k // keep from <left> where <right>
l // base-10 log of <mid>
m // integer combinations using top of <left> and <right>
n // split <mid> on newlines
o // order
p // prime factorization
q // every instruction traversed so far, in order
r // round
s // sine
t // tangent
u // rotate the mid stack by <mid>
v // absolute value
w // remove the <nth> elements from the <mid> stack
x // to lowercase
y // is lowercase
z // conjugate
{ // loop if <right> is true or empty
| // reflection around the vertical
} // loop if <right> is true or empty
~ // negate
‚ê° // clear the console
‚Äº // output all of <mid>
‚Åá // get all input, put into <mid>
‚Åà // output <right>, read into <left>
‚Åâ // output <left>, read into <right>
‚ÄΩ // output and pop <mid>, read into <mid>
√ó // multiply
‚®∞ // vectorized multiplication
√∑ // divide
‚àî // vectorized plus
‚à∏ // vectorized subtraction
‚∏û // vectorized negation
‚àö // square root
‚Öü // reciprocal
‚àû // is a non-finite number, and not NaN
‚à® // or
‚©í // vectorized or
‚àß // and
‚©ë // vectorized and
‚äª // xor
¬¨ // not
‚ä® // coalesce to truthy/falsey
‚ä≠ // logical negation
‚à© // intersection
‚à™ // union
‚àÅ // exclusion
‚àà // element of
‚ãµ // vectorized element-of
‚ãñ // vectorized less-than
‚ãó // vectorized greater-than
‚âê // vectorized equals
‚©Ω // less or equals
‚©ø // vectorized less-or-equals
‚©æ // greater or equals
‚™Ä // vectorized greater-or-equals
‚â† // not equals
‚â° // identical to (stack equals)
‚ää // subset but not equal
‚äÜ // subset or equal
‚äà // not subset nor equal
√• // radians to angle
√Ö // angle to radians
¬Ø // ceiling
¬´ // left-shift
¬ª // right-shift
‚åõ // hourglass symbol (sleep)
‚åö // watch symbol (timestamp)
œÄ // pi
‚áî // swap the left and right stacks
‚áñ // move the <mid> stack onto the <left> stack
‚áó // move the <mid> stack onto the <right> stack
‚áò // move the <left> stack into the <mid> stack
‚áô // move the <right> stack into the <mid> stack
√ô // upend the left stack
√ö // upend the right stack
√ú // upend the left and right stacks
≈™ // upend the primary stack
·ª§ // upend from baseline
√õ // upend every substack
√π // rotate left stack by <mid>
√∫ // rotate right stack by <mid>
√º // rotate left and right stacks by <mid>
≈´ // rotate primary stack
·ª• // rotate from baseline by <mid>
√ª // rotate every substack
·∫Ä // wipe the left stack
·∫Ç // wipe the right stack
·∫Ñ // wipe the left and right stacks
·∫à // wipe from baseline
·∫Ü // wipe the main stack
≈¥ // wipe every substack
·∫Å // remove the <mid-th> elements from the left stack
·∫É // remove the <mid-th> elements from the right stack
·∫Ö // remove the <mid-th> elements from the left and right stacks
·∫â // remove the <mid-th> elements from baseline stack
‚Öã // un-join the middle stack
‚§± // mid -> right, mid -> left
‚§≤ // mid -> left, mid -> right
‚§° // swap top of left and mid
‚§¢ // swap top of right and mid
‚≠§ // swap top of right and left
‚≠• // swap top and bottom of mid
‚≠¢ // move top of left to right
‚≠† // move top of right to left
‚≠£ // move top of mid down one (swap top two)
‚≠¶ // move top of mid to left
‚≠ß // move top of mid to right
‚≠® // move top of left to mid
‚≠© // move top of right to mid
‚≠≤ // copy top of left to right
‚≠∞ // copy top of right to left
‚≠± // copy top of mid
‚≠∂ // copy top of mid to left
‚≠∑ // copy top of mid to right
‚≠∏ // copy top of left to mid
‚≠π // copy top of right to mid
‚≠æ // copy top of left and right to eachother
‚≠ø // copy top and bottom of mid to eachother
‚Æê // rotate stacks clockwise
‚Æë // rotate stacks counterclockwise
‚Æí // rotate tops of stacks clockwise
‚Æì // rotate tops of stacks counterclockwise
‚Ññ // number of stacks from the cursor upwards
»æ // transpose from cursor upwards
‚àè // product
‚àë // sum
‚àÉ // any
‚àÄ // all
ùí´ // power set
ùíÆ // ordered subsets
‚¨à // bounce NE
‚¨â // bounce NW
‚¨ä // bounce SE
‚¨ã // bounce SW
‚¨ú // universal reflect
‚¨ö // conditional universal reflect
‚óã // jump over next instruction
‚óå // conditional jump over next instruction
‚©∏ // group by equality
‚àÖ // the empty set
·∏å // remove duplicates from <baseline>
·∏ç // retain only duplicates from <baseline>
‚§î // copy from <baseline> onto end of <main>
‚Ü¶ // duplicate top element of <mid> into a new stack
‚Ü£ // duplciate <mid>
‚§Ö // repeat top element of <mid> forever
‚§ñ // repeat <mid> forever
·∏¶ // maximum of tops of <left> and <right>
·∏ß // minimum of tops of <left> and <right>